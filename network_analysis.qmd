---
title: "Network Analysis"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: show
    number-sections: true
execute:
  echo: true
  warning: false
  message: true
---

# Overview

This pipeline provides a Network Analysis of the GEN26 universities.

# Pipeline

1.  Basic Network Statistics
2.  Borgatti-Everett Core-Periphery Model
3.  Bar Chart
4.  Export for QGIS

## Basic Network Statistics

### Packages

```{r}
library(dplyr)
library(igraph)
library(tidyr)
```

### Read CSV

```{r}
c_preview_geocoded <- read.csv("c_preview_geocoded.csv", stringsAsFactors = FALSE)
```

### Define Target Universities

```{r}
# Define all 5 GEN26 universities from your data
TARGET_UNIVERSITIES <- c(
  "Università Bocconi",
  "Università degli studi di Verona", 
  "Università Cattolica del Sacro Cuore",
  "Università IULM Milano",
  "Politecnico di Milano"
)
```

### Calculate Full Network Statistics

```{r}
# Calculate Full Network Statistics (All 5 Universities)
calculate_full_network_stats <- function(c_preview_geocoded, all_universities) {

  # 1. NODES: All 5 universities (including isolated ones)
  nodes <- length(all_universities)

  # 2. Create collaboration pairs from c_preview_geocoded
  collab_pairs <- c_preview_geocoded %>%
    select(eid, affil) %>%
    distinct() %>%
    # Create all pairwise combinations within each publication
    group_by(eid) %>%
    do({
      unis <- .$affil
      if(length(unis) >= 2) {
        expand.grid(uni1 = unis, uni2 = unis, stringsAsFactors = FALSE) %>%
          filter(uni1 < uni2)  # Avoid duplicates and self-loops
      } else {
        data.frame(uni1 = character(0), uni2 = character(0))
      }
    }) %>%
    ungroup()

  # Count collaborations between each university pair
  edge_weights <- collab_pairs %>%
    count(uni1, uni2, name = "weight") %>%
    arrange(uni1, uni2)

  # 3. EDGES: Number of collaboration relationships
  edges <- nrow(edge_weights)

  # 4. Create igraph network including ALL universities
  # Start with empty graph of all universities
  g <- make_empty_graph(n = 0, directed = FALSE)
  g <- add_vertices(g, nodes, name = all_universities)

  # Add edges if they exist
  if(edges > 0) {
    # Add edges to the graph
    edge_list <- as.matrix(edge_weights[, c("uni1", "uni2")])
    g <- add_edges(g, t(edge_list))
    E(g)$weight <- edge_weights$weight
  }

  # Calculate degrees for ALL vertices
  degrees <- degree(g)
  mean_degree <- mean(degrees)
  median_degree <- median(degrees)

  # Identify isolated nodes
  isolated_nodes <- sum(degrees == 0)

  # 5. WEIGHT SUMMARY
  total_weight <- sum(edge_weights$weight, na.rm = TRUE)
  mean_weight <- if(edges > 0) mean(edge_weights$weight) else 0

  # 6. DENSITY CALCULATION
  max_possible_edges <- nodes * (nodes - 1) / 2
  density <- if(max_possible_edges > 0) edges / max_possible_edges else 0

  # Return results
  list(
    nodes = nodes,
    edges = edges,
    mean_degree = round(mean_degree, 2),
    median_degree = median_degree,
    total_weight = total_weight,
    mean_weight = round(mean_weight, 2),
    density = round(density, 3),
    isolated_nodes = isolated_nodes,
    max_possible_edges = max_possible_edges,
    degree_distribution = degrees
  )
}

# Calculate the full network statistics
full_stats <- calculate_full_network_stats(c_preview_geocoded, TARGET_UNIVERSITIES)
```

### Display results

```{r}
# Display results
cat("=== FULL GEN26 NETWORK STATISTICS ===\n")
cat("Nodes (Universities):", full_stats$nodes, "\n")
cat("Edges (Collaborations):", full_stats$edges, "\n")
cat("Mean Degree:", full_stats$mean_degree, "\n")
cat("Median Degree:", full_stats$median_degree, "\n")
cat("Total Weight (Publications):", full_stats$total_weight, "\n")
cat("Mean Weight per Edge:", full_stats$mean_weight, "\n")
cat("Network Density:", full_stats$density, "\n")
cat("Isolated Nodes:", full_stats$isolated_nodes, "\n")

# Create summary table
network_summary <- data.frame(
  Metric = c("Nodes", "Edges", "Mean Degree", "Median Degree", 
             "Total Weight", "Mean Weight", "Density", "Isolated Nodes"),
  Value = c(full_stats$nodes, full_stats$edges, 
            full_stats$mean_degree, full_stats$median_degree,
            full_stats$total_weight, full_stats$mean_weight,
            full_stats$density, full_stats$isolated_nodes),
  Description = c("Total universities in consortium", 
                  "Active collaboration relationships",
                  "Average partners per university",
                  "Median partners per university", 
                  "Total collaborative publications",
                  "Average publications per partnership",
                  "Proportion of possible connections",
                  "Universities with no collaborations")
)

print(network_summary)

# Show degree distribution
cat("\n=== DEGREE DISTRIBUTION ===\n")
degree_table <- data.frame(
  University = names(full_stats$degree_distribution),
  Degree = as.numeric(full_stats$degree_distribution)
) %>%
  arrange(desc(Degree))

print(degree_table)
```

## **Borgatti-Everett Core-Periphery Model**

### Packages

```{r}
library(netUtils)
library(igraph)
library(dplyr)
library(GA)
library(ggplot2)
library(maps)
library(geosphere)
```

### Read CSV

```{r}
c_preview_geocoded <- read.csv("c_preview_geocoded.csv", stringsAsFactors = FALSE)
```

### Define Target Universities

```{r}
# Define all 5 GEN26 universities
TARGET_UNIVERSITIES <- c(
  "Università Bocconi",
  "Università degli studi di Verona", 
  "Università Cattolica del Sacro Cuore",
  "Università IULM Milano",
  "Politecnico di Milano"
)
```

### Create igraph Network

```{r}
# Function to create igraph network from c_preview_geocoded data
create_gen26_network <- function(c_preview_geocoded, all_universities) {

  # Create collaboration pairs
  collab_pairs <- c_preview_geocoded %>%
    select(eid, affil) %>%
    distinct() %>%
    group_by(eid) %>%
    do({
      unis <- .$affil
      if(length(unis) >= 2) {
        expand.grid(uni1 = unis, uni2 = unis, stringsAsFactors = FALSE) %>%
          filter(uni1 < uni2)
      } else {
        data.frame(uni1 = character(0), uni2 = character(0))
      }
    }) %>%
    ungroup()

  # Count collaboration weights
  edge_weights <- collab_pairs %>%
    count(uni1, uni2, name = "weight")

  # Get university coordinates
  uni_coords <- c_preview_geocoded %>%
    select(affil, latitude, longitude) %>%
    distinct()

  # Create igraph network with all universities
  g <- make_empty_graph(n = 0, directed = FALSE)
  g <- add_vertices(g, length(all_universities), name = all_universities)

  # Add coordinates as vertex attributes
  for(i in 1:length(all_universities)) {
    uni_name <- all_universities[i]
    coords <- uni_coords[uni_coords$affil == uni_name, ]
    if(nrow(coords) > 0) {
      V(g)[uni_name]$latitude <- coords$latitude[1]
      V(g)[uni_name]$longitude <- coords$longitude[1]
    } else {
      # Default coordinates if not found
      V(g)[uni_name]$latitude <- NA
      V(g)[uni_name]$longitude <- NA
    }
  }

  # Add edges if they exist
  if(nrow(edge_weights) > 0) {
    edge_list <- as.matrix(edge_weights[, c("uni1", "uni2")])
    g <- add_edges(g, t(edge_list))
    E(g)$weight <- edge_weights$weight
  }

  return(list(graph = g, edge_weights = edge_weights, uni_coords = uni_coords))
}

# Create the network
gen26_data <- create_gen26_network(c_preview_geocoded, TARGET_UNIVERSITIES)
gen26_network <- gen26_data$graph
```

### Borgatti-Everett Core-Periphery Model

```{r}
# Apply Borgatti-Everett Core-Periphery Model
borgatti_everett_analysis <- function(network) {

  cat("=== BORGATTI-EVERETT CORE-PERIPHERY ANALYSIS ===\n\n")

  # Method 1: Rank-1 approximation with degree centrality (fastest)
  cp_rk1_dc <- core_periphery(network, method = "rk1_dc")

  # Method 2: Rank-1 approximation with eigenvector centrality
  cp_rk1_ec <- core_periphery(network, method = "rk1_ec")

  # Method 3: Genetic Algorithm (most accurate but slower)
  cp_ga <- core_periphery(network, method = "GA", iter = 500)

  # Create results summary
  university_names <- V(network)$name

  results_table <- data.frame(
    University = university_names,
    RK1_DC_Assignment = cp_rk1_dc$vec,
    RK1_EC_Assignment = cp_rk1_ec$vec,
    GA_Assignment = cp_ga$vec,
    RK1_DC_Role = ifelse(cp_rk1_dc$vec == 1, "CORE", "PERIPHERY"),
    RK1_EC_Role = ifelse(cp_rk1_ec$vec == 1, "CORE", "PERIPHERY"),
    GA_Role = ifelse(cp_ga$vec == 1, "CORE", "PERIPHERY")
  )

  # Display results
  cat("CORE-PERIPHERY ASSIGNMENTS:\n")
  print(results_table[, c("University", "RK1_DC_Role", "RK1_EC_Role", "GA_Role")])

  cat("\nCORRELATION WITH IDEAL CORE-PERIPHERY STRUCTURE:\n")
  cat("Rank-1 Degree Centrality:", round(cp_rk1_dc$corr, 3), "\n")
  cat("Rank-1 Eigenvector Centrality:", round(cp_rk1_ec$corr, 3), "\n")
  cat("Genetic Algorithm:", round(cp_ga$corr, 3), "\n")

  # Consensus analysis
  consensus <- data.frame(
    University = university_names,
    Core_Votes = cp_rk1_dc$vec + cp_rk1_ec$vec + cp_ga$vec,
    Consensus_Role = ifelse((cp_rk1_dc$vec + cp_rk1_ec$vec + cp_ga$vec) >= 2, "CORE", "PERIPHERY")
  )

  cat("\nCONSENSUS CORE-PERIPHERY STRUCTURE:\n")
  print(consensus[, c("University", "Core_Votes", "Consensus_Role")])

  # Network statistics by role
  core_unis <- consensus$University[consensus$Consensus_Role == "CORE"]
  periphery_unis <- consensus$University[consensus$Consensus_Role == "PERIPHERY"]

  cat("\nNETWORK STRUCTURE SUMMARY:\n")
  cat("Core Universities:", length(core_unis), "-", paste(core_unis, collapse = ", "), "\n")
  cat("Periphery Universities:", length(periphery_unis), "-", paste(periphery_unis, collapse = ", "), "\n")

  # Calculate core-periphery fit quality
  best_method <- which.max(c(cp_rk1_dc$corr, cp_rk1_ec$corr, cp_ga$corr))
  method_names <- c("Rank-1 Degree Centrality", "Rank-1 Eigenvector Centrality", "Genetic Algorithm")

  cat("\nBEST FIT METHOD:", method_names[best_method], "\n")
  cat("STRUCTURE FIT QUALITY:", round(max(cp_rk1_dc$corr, cp_rk1_ec$corr, cp_ga$corr), 3), "\n")

  return(list(
    rk1_dc = cp_rk1_dc,
    rk1_ec = cp_rk1_ec,
    ga = cp_ga,
    consensus = consensus,
    results_table = results_table
  ))
}

# Run the analysis
cp_results <- borgatti_everett_analysis(gen26_network)
```

### Visualize - Borgatti-Everett Core-Periphery Model

```{r}
# Original network visualization
visualize_core_periphery <- function(network, cp_result) {

  # Set node colors based on core-periphery assignment
  node_colors <- ifelse(cp_result$consensus$Consensus_Role == "CORE", "red", "lightblue")
  node_sizes <- ifelse(cp_result$consensus$Consensus_Role == "CORE", 20, 15)

  # Plot network
  plot(network,
       vertex.color = node_colors,
       vertex.size = node_sizes,
       vertex.label = V(network)$name,
       vertex.label.cex = 0.8,
       vertex.label.color = "black",
       edge.width = 2,
       edge.color = "gray",
       layout = layout_with_fr(network),
       main = "GEN26 Universities: Core-Periphery Structure\n(Red = Core, Blue = Periphery)")

  # Add legend
  legend("topright", 
         legend = c("Core", "Periphery"), 
         col = c("red", "lightblue"), 
         pch = 19, 
         cex = 0.8)
}

# Create all visualizations
cat("\n=== CREATING VISUALIZATIONS ===\n")

# 1. Original core-periphery network plot
visualize_core_periphery(gen26_network, cp_results)
```

### Visualize - Edges and Weight Map

```{r}
# FIXED MAP 1: Edges and Weights Visualization with Coordinate Reference System
create_edges_map <- function(gen26_data, cp_results) {

  # Check if we have edges to plot
  if(nrow(gen26_data$edge_weights) == 0) {
    cat("No edges to plot - creating nodes-only map\n")

    ggplot() +
      geom_point(data = gen26_data$uni_coords,
                 aes(x = longitude, y = latitude),
                 color = "red", size = 4, alpha = 0.8) +
      geom_text(data = gen26_data$uni_coords,
                aes(x = longitude, y = latitude, label = affil),
                vjust = -0.5, hjust = 0.5, size = 3, fontface = "bold") +
      scale_x_continuous(name = "Longitude") +
      scale_y_continuous(name = "Latitude") +
      theme_minimal() +
      theme(axis.title = element_text(size = 10, face = "bold"),
            axis.text = element_text(size = 9),
            panel.grid.major = element_line(color = "gray90"),
            panel.grid.minor = element_line(color = "gray95")) +
      labs(title = "GEN26 Universities - No Collaborations Found",
           subtitle = "Red dots represent university locations")

  } else {

    # Prepare edge data with coordinates
    edges_with_coords <- gen26_data$edge_weights %>%
      mutate(weight_factor = as.factor(weight)) %>%
      left_join(gen26_data$uni_coords, by = c("uni1" = "affil")) %>%
      rename(lat1 = latitude, lon1 = longitude) %>%
      left_join(gen26_data$uni_coords, by = c("uni2" = "affil")) %>%
      rename(lat2 = latitude, lon2 = longitude)

    # Create curved edges with proper error handling
    edges_curved <- edges_with_coords %>%
      rowwise() %>%
      mutate(
        path_data = list({
          tryCatch({
            path_result <- gcIntermediate(c(lon1, lat1), c(lon2, lat2), 
                                        n = 30, addStartEnd = TRUE)
            # Convert to data frame with proper column names
            if(is.matrix(path_result)) {
              data.frame(lon = path_result[,1], lat = path_result[,2])
            } else {
              data.frame(lon = c(lon1, lon2), lat = c(lat1, lat2))
            }
          }, error = function(e) {
            # Fallback to straight line
            data.frame(lon = c(lon1, lon2), lat = c(lat1, lat2))
          })
        })
      ) %>%
      ungroup() %>%
      select(-lat1, -lon1, -lat2, -lon2) %>%
      unnest(path_data)

    # Plot edges map with discrete colors and coordinate system
    ggplot() +
      geom_path(data = edges_curved,
                aes(x = lon, y = lat, 
                    group = interaction(uni1, uni2),
                    color = weight_factor, size = weight),
                alpha = 0.7) +
      geom_point(data = gen26_data$uni_coords,
                 aes(x = longitude, y = latitude),
                 color = "red", size = 4, alpha = 0.8) +
      geom_text(data = gen26_data$uni_coords,
                aes(x = longitude, y = latitude, label = affil),
                vjust = -0.5, hjust = 0.5, size = 3, fontface = "bold") +
      scale_x_continuous(name = "Longitude") +
      scale_y_continuous(name = "Latitude") +
      scale_color_brewer(palette = "Blues", direction = 1, 
                         name = "Collaborations") +
      scale_size_continuous(range = c(1, 4), guide = "none") +
      theme_minimal() +
      theme(axis.title = element_text(size = 10, face = "bold"),
            axis.text = element_text(size = 9),
            panel.grid.major = element_line(color = "gray90"),
            panel.grid.minor = element_line(color = "gray95")) +
      labs(title = "GEN26 University Collaboration Network - Edges and Weights",
           subtitle = "Edge thickness and color represent collaboration intensity")
  }
}

# 2. Edges and weights map
edges_map <- create_edges_map(gen26_data, cp_results)
print(edges_map)
```

### Display results

```{r}
# Export summary data
network_summary <- list(
  total_universities = length(TARGET_UNIVERSITIES),
  active_collaborations = nrow(gen26_data$edge_weights),
  total_collaborative_papers = sum(gen26_data$edge_weights$weight),
  core_universities = sum(cp_results$consensus$Consensus_Role == "CORE"),
  periphery_universities = sum(cp_results$consensus$Consensus_Role == "PERIPHERY")
)

cat("\n=== NETWORK SUMMARY ===\n")
print(network_summary)
```

## Bar Chart

```{r}
library(ggplot2)
library(dplyr)
library(igraph)

# Create edge list from collaboration data
collab_pairs <- c_preview_geocoded %>%
  select(eid, affil) %>%
  distinct() %>%
  group_by(eid) %>%
  do({
    unis <- .$affil
    if(length(unis) >= 2) {
      expand.grid(uni1 = unis, uni2 = unis, stringsAsFactors = FALSE) %>%
        filter(uni1 < uni2)
    } else {
      data.frame(uni1 = character(0), uni2 = character(0))
    }
  }) %>%
  ungroup() %>%
  count(uni1, uni2, name = "weight")

# Create network graph
g <- graph_from_data_frame(collab_pairs, directed = FALSE, 
                           vertices = data.frame(name = TARGET_UNIVERSITIES))
E(g)$weight <- collab_pairs$weight

# Calculate node metrics
node_data <- data.frame(
  University = V(g)$name,
  Degree = degree(g),
  Betweenness = betweenness(g, weights = NA),
  Collaborations = strength(g)
) %>%
  mutate(Collaborations = as.factor(Collaborations)) %>%
  arrange(desc(Degree))

# Create visualization with discrete colors
ggplot(node_data, aes(x = reorder(University, Degree), y = Degree)) +
  geom_col(aes(fill = Collaborations), width = 0.7) +
  geom_text(aes(label = Degree), hjust = -0.3, size = 3.5) +
  scale_fill_brewer(palette = "Blues", direction = 1,
                    name = "Total\nCollaborations") +
  coord_flip() +
  labs(
    title = "University Collaboration Network Metrics",
    subtitle = "Number of partner institutions and total collaborative publications",
    x = NULL,
    y = "Number of Partner Universities (Degree)"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 10, color = "gray40"),
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "right"
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15)))

```

# Export for QGIS

```{r}
# QGIS Export Code for GEN26 Network - Shapefiles and CSV only
library(dplyr)
library(sf)

# Function to create QGIS-ready files
export_qgis_network_files <- function(gen26_data, cp_results, output_dir = "qgis_export") {

  # Create output directory
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }

  # 1. CREATE NODES SHAPEFILE
  nodes_data <- gen26_data$uni_coords %>%
    left_join(cp_results$consensus, by = c("affil" = "University")) %>%
    mutate(
      uni_id = row_number(),
      uni_name = affil,
      cp_role = ifelse(is.na(Consensus_Role), "PERIPHERY", Consensus_Role),
      core_votes = ifelse(is.na(Core_Votes), 0, Core_Votes),
      node_size = ifelse(cp_role == "CORE", 8, 5),
      node_color = ifelse(cp_role == "CORE", "red", "blue")
    ) %>%
    select(uni_id, uni_name, cp_role, core_votes, node_size, node_color, latitude, longitude)

  # Convert to sf object (POINT geometry)
  nodes_sf <- st_as_sf(nodes_data, 
                       coords = c("longitude", "latitude"), 
                       crs = 4326)

  nodes_file <- file.path(output_dir, "gen26_universities.shp")
  st_write(nodes_sf, nodes_file, delete_dsn = TRUE, quiet = TRUE)

  # 2. CREATE EDGES SHAPEFILE (LINESTRING geometry)
  if(nrow(gen26_data$edge_weights) > 0) {
    edges_with_coords <- gen26_data$edge_weights %>%
      left_join(gen26_data$uni_coords, by = c("uni1" = "affil")) %>%
      rename(lat1 = latitude, lon1 = longitude) %>%
      left_join(gen26_data$uni_coords, by = c("uni2" = "affil")) %>%
      rename(lat2 = latitude, lon2 = longitude) %>%
      mutate(
        edge_id = row_number(),
        collab_wt = weight,
        line_width = weight * 0.5
      )

    # Create LINESTRING geometries
    edges_geom <- lapply(1:nrow(edges_with_coords), function(i) {
      edge <- edges_with_coords[i, ]
      st_linestring(matrix(c(edge$lon1, edge$lat1, edge$lon2, edge$lat2), 
                          ncol = 2, byrow = TRUE))
    })

    # Create sf object for edges
    edges_sf <- st_sf(
      edge_id = edges_with_coords$edge_id,
      uni1 = edges_with_coords$uni1,
      uni2 = edges_with_coords$uni2,
      weight = edges_with_coords$collab_wt,
      line_width = edges_with_coords$line_width,
      geometry = st_sfc(edges_geom, crs = 4326)
    )

    edges_file <- file.path(output_dir, "gen26_collaborations.shp")
    st_write(edges_sf, edges_file, delete_dsn = TRUE, quiet = TRUE)
  } else {
    edges_file <- NULL
    cat("Warning: No collaborations to export\n")
  }

  # 3. CREATE CSV FILES
  nodes_csv <- file.path(output_dir, "universities_coordinates.csv")
  write.csv(nodes_data, nodes_csv, row.names = FALSE)

  if(nrow(gen26_data$edge_weights) > 0) {
    edges_csv_data <- gen26_data$edge_weights %>%
      left_join(gen26_data$uni_coords, by = c("uni1" = "affil")) %>%
      rename(hub_lat = latitude, hub_lon = longitude, hub_name = uni1) %>%
      left_join(gen26_data$uni_coords, by = c("uni2" = "affil")) %>%
      rename(spoke_lat = latitude, spoke_lon = longitude, spoke_name = uni2) %>%
      select(hub_name, hub_lat, hub_lon, spoke_name, spoke_lat, spoke_lon, weight)

    edges_csv <- file.path(output_dir, "collaborations_coordinates.csv")
    write.csv(edges_csv_data, edges_csv, row.names = FALSE)
  } else {
    edges_csv <- NULL
  }

  # Print summary
  cat("\n=== QGIS EXPORT SUMMARY ===\n")
  cat("Output directory:", normalizePath(output_dir), "\n\n")
  cat("Shapefiles:\n")
  cat("  - Nodes:", basename(nodes_file), "\n")
  if(!is.null(edges_file)) cat("  - Edges:", basename(edges_file), "\n")
  cat("\nCSV files:\n")
  cat("  - Nodes:", basename(nodes_csv), "\n")
  if(!is.null(edges_csv)) cat("  - Edges:", basename(edges_csv), "\n")
  cat("\nData summary:\n")
  cat("  - Total universities:", nrow(nodes_data), "\n")
  cat("  - Total collaborations:", nrow(gen26_data$edge_weights), "\n")
  cat("  - Core universities:", sum(nodes_data$cp_role == "CORE"), "\n")
  cat("  - Periphery universities:", sum(nodes_data$cp_role == "PERIPHERY"), "\n\n")

  return(list(
    nodes_shp = nodes_file,
    edges_shp = edges_file,
    nodes_csv = nodes_csv,
    edges_csv = edges_csv,
    output_dir = normalizePath(output_dir)
  ))
}

# Execute the export
qgis_files <- export_qgis_network_files(gen26_data, cp_results)

```

```{r}
# QGIS Export Code for GEN26 Network - Shapefiles and CSV only
library(dplyr)
library(sf)

# Function to create QGIS-ready files
export_qgis_network_files <- function(gen26_data, cp_results, output_dir = "qgis_export") {

  # Create output directory
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }

  # 1. CREATE NODES SHAPEFILE
  nodes_data <- gen26_data$uni_coords %>%
    left_join(cp_results$consensus, by = c("affil" = "University")) %>%
    mutate(
      uni_id = row_number(),
      uni_name = affil,
      cp_role = ifelse(is.na(Consensus_Role), "PERIPHERY", Consensus_Role),
      core_votes = ifelse(is.na(Core_Votes), 0, Core_Votes),
      node_size = ifelse(cp_role == "CORE", 8, 5),
      node_color = ifelse(cp_role == "CORE", "red", "blue")
    ) %>%
    select(uni_id, uni_name, cp_role, core_votes, node_size, node_color, latitude, longitude)

  # Convert to sf object (POINT geometry)
  nodes_sf <- st_as_sf(nodes_data, 
                       coords = c("longitude", "latitude"), 
                       crs = 4326)

  nodes_file <- file.path(output_dir, "gen26_universities.shp")
  st_write(nodes_sf, nodes_file, delete_dsn = TRUE, quiet = TRUE)

  # 2. CREATE EDGES SHAPEFILE (LINESTRING geometry)
  if(nrow(gen26_data$edge_weights) > 0) {
    edges_with_coords <- gen26_data$edge_weights %>%
      left_join(gen26_data$uni_coords, by = c("uni1" = "affil")) %>%
      rename(lat1 = latitude, lon1 = longitude) %>%
      left_join(gen26_data$uni_coords, by = c("uni2" = "affil")) %>%
      rename(lat2 = latitude, lon2 = longitude) %>%
      mutate(
        edge_id = row_number(),
        collab_wt = weight,
        line_width = weight * 0.5
      )

    # Create LINESTRING geometries
    edges_geom <- lapply(1:nrow(edges_with_coords), function(i) {
      edge <- edges_with_coords[i, ]
      st_linestring(matrix(c(edge$lon1, edge$lat1, edge$lon2, edge$lat2), 
                          ncol = 2, byrow = TRUE))
    })

    # Create sf object for edges
    edges_sf <- st_sf(
      edge_id = edges_with_coords$edge_id,
      uni1 = edges_with_coords$uni1,
      uni2 = edges_with_coords$uni2,
      weight = edges_with_coords$collab_wt,
      line_width = edges_with_coords$line_width,
      geometry = st_sfc(edges_geom, crs = 4326)
    )

    edges_file <- file.path(output_dir, "gen26_collaborations.shp")
    st_write(edges_sf, edges_file, delete_dsn = TRUE, quiet = TRUE)
  } else {
    edges_file <- NULL
    cat("Warning: No collaborations to export\n")
  }

  # 3. CREATE CSV FILES
  nodes_csv <- file.path(output_dir, "universities_coordinates.csv")
  write.csv(nodes_data, nodes_csv, row.names = FALSE)

  if(nrow(gen26_data$edge_weights) > 0) {
    edges_csv_data <- gen26_data$edge_weights %>%
      left_join(gen26_data$uni_coords, by = c("uni1" = "affil")) %>%
      rename(hub_lat = latitude, hub_lon = longitude, hub_name = uni1) %>%
      left_join(gen26_data$uni_coords, by = c("uni2" = "affil")) %>%
      rename(spoke_lat = latitude, spoke_lon = longitude, spoke_name = uni2) %>%
      select(hub_name, hub_lat, hub_lon, spoke_name, spoke_lat, spoke_lon, weight)

    edges_csv <- file.path(output_dir, "collaborations_coordinates.csv")
    write.csv(edges_csv_data, edges_csv, row.names = FALSE)
  } else {
    edges_csv <- NULL
  }

  # Print summary
  cat("\n=== QGIS EXPORT SUMMARY ===\n")
  cat("Output directory:", normalizePath(output_dir), "\n\n")
  cat("Shapefiles:\n")
  cat("  - Nodes:", basename(nodes_file), "\n")
  if(!is.null(edges_file)) cat("  - Edges:", basename(edges_file), "\n")
  cat("\nCSV files:\n")
  cat("  - Nodes:", basename(nodes_csv), "\n")
  if(!is.null(edges_csv)) cat("  - Edges:", basename(edges_csv), "\n")
  cat("\nData summary:\n")
  cat("  - Total universities:", nrow(nodes_data), "\n")
  cat("  - Total collaborations:", nrow(gen26_data$edge_weights), "\n")
  cat("  - Core universities:", sum(nodes_data$cp_role == "CORE"), "\n")
  cat("  - Periphery universities:", sum(nodes_data$cp_role == "PERIPHERY"), "\n\n")

  return(list(
    nodes_shp = nodes_file,
    edges_shp = edges_file,
    nodes_csv = nodes_csv,
    edges_csv = edges_csv,
    output_dir = normalizePath(output_dir)
  ))
}

# Execute the export
qgis_files <- export_qgis_network_files(gen26_data, cp_results)
```
